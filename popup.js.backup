/**
 * Yoink Popup Script
 *
 * Handles the extension popup UI interactions:
 * - Triggers style scanning on the active tab
 * - Receives extracted styles from content script
 * - Generates Markdown design system
 * - Provides copy to clipboard and download functionality
 */

// DOM element references
const scanBtn = document.getElementById('scanBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const loadingState = document.getElementById('loadingState');
const resultsSection = document.getElementById('resultsSection');
const errorState = document.getElementById('errorState');
const markdownPreview = document.getElementById('markdownPreview');
const successMessage = document.getElementById('successMessage');

// Store the generated markdown globally for copy/download operations
let generatedMarkdown = '';

/**
 * Initialize popup when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', () => {
  // Attach event listeners
  scanBtn.addEventListener('click', handleScan);
  copyBtn.addEventListener('click', handleCopy);
  downloadBtn.addEventListener('click', handleDownload);
});

/**
 * Handles the scan button click
 * Sends a message to the content script to extract page styles
 */
async function handleScan() {
  try {
    // Update UI to show loading state
    showLoading();

    // Get the active tab
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

    // Send message to content script to scan the page
    chrome.tabs.sendMessage(
      tab.id,
      { action: 'scanStyles' },
      (response) => {
        if (chrome.runtime.lastError) {
          console.error('Error:', chrome.runtime.lastError);
          showError();
          return;
        }

        if (response && response.success) {
          // Process the extracted styles
          handleScanResults(response.data, tab.url);
        } else {
          showError();
        }
      }
    );
  } catch (error) {
    console.error('Scan error:', error);
    showError();
  }
}

/**
 * Processes scan results and generates Markdown
 * @param {Object} styleData - Extracted style data from content script
 * @param {string} url - The URL of the scanned page
 */
function handleScanResults(styleData, url) {
  // Generate Markdown design system
  generatedMarkdown = generateMarkdown(styleData, url);

  // Update preview
  markdownPreview.textContent = generatedMarkdown;

  // Show results section
  showResults();
}

/**
 * Generates a Markdown design system from extracted styles
 * @param {Object} styles - Style data object
 * @param {string} url - Source URL
 * @returns {string} - Formatted Markdown document
 */
function generateMarkdown(styles, url) {
  const timestamp = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  let markdown = `# Design System\n\n`;
  markdown += `**Source:** ${url}\n`;
  markdown += `**Extracted:** ${timestamp}\n`;
  markdown += `**Generated by:** Yoink Extension\n\n`;
  markdown += `---\n\n`;

  // Generate enhanced color section with CSS variables
  markdown += generateColorSection(styles);

  // Keep existing sections for other design tokens
  markdown += generateTypographySection(styles);
  markdown += generateSpacingSection(styles);
  markdown += generateBorderRadiusSection(styles);
  markdown += generateShadowsSection(styles);

  // Footer with usage notes
  markdown += `---\n\n`;
  markdown += `## ğŸ“– Usage Notes\n\n`;
  markdown += `This design system was automatically extracted from the web page. `;
  markdown += `CSS custom properties (variables) have been extracted and mapped to their computed values.\n\n`;
  markdown += `### Next Steps\n\n`;
  markdown += `1. Use the CSS variable names (e.g., \`var(--medical-primary)\`) in your code\n`;
  markdown += `2. Review and consolidate duplicate semantic names\n`;
  markdown += `3. Verify theme variants work correctly in light/dark modes\n`;
  markdown += `4. Integrate into your design system or component library\n`;

  return markdown;
}

/**
 * Generates the enhanced color section with semantic CSS variables
 * @param {Object} styles - Style data object
 * @returns {string} - Formatted color section
 */
function generateColorSection(styles) {
  let section = `## ğŸ¨ Colors\n\n`;

  // Group CSS variables by prefix
  const groupedVars = groupCSSVariablesByPrefix(styles.cssVariables);

  // Generate sections for each prefix group
  if (Object.keys(groupedVars).length > 0) {
    for (const [prefix, variables] of Object.entries(groupedVars)) {
      section += generatePrefixSection(prefix, variables, styles);
    }
  }

  // Show computed colors without CSS variables
  const computedColors = findUnmappedColors(styles);
  if (computedColors.length > 0) {
    section += `### Computed Colors (no CSS variable found)\n\n`;
    computedColors.forEach((color, index) => {
      section += `- **Color ${index + 1}**: \`${color}\`\n`;
    });
    section += `\n`;
  }

  return section;
}

/**
 * Groups CSS variables by their prefix (e.g., medical-, sidebar-, etc.)
 * @param {Object} cssVars - CSS variables object
 * @returns {Object} - Grouped variables
 */
function groupCSSVariablesByPrefix(cssVars) {
  const groups = {
    'brand': [],      // medical-, brand-, company- prefixes
    'sidebar': [],    // sidebar- prefix
    'chart': [],      // chart-, graph-, data- prefixes
    'semantic': [],   // background, foreground, primary, secondary, accent, etc.
    'other': []       // everything else
  };

  for (const [varName, themes] of Object.entries(cssVars || {})) {
    const cleanName = varName.replace('--', '');
    const lower = cleanName.toLowerCase();

    // Categorize by prefix
    if (lower.startsWith('medical-') || lower.startsWith('brand-') || lower.startsWith('company-')) {
      groups.brand.push({ name: varName, themes });
    } else if (lower.startsWith('sidebar-')) {
      groups.sidebar.push({ name: varName, themes });
    } else if (lower.startsWith('chart-') || lower.startsWith('graph-') || lower.startsWith('data-')) {
      groups.chart.push({ name: varName, themes });
    } else if (['background', 'foreground', 'primary', 'secondary', 'accent', 'muted', 'border', 'input', 'ring'].some(s => lower.includes(s))) {
      groups.semantic.push({ name: varName, themes });
    } else {
      groups.other.push({ name: varName, themes });
    }
  }

  // Remove empty groups
  return Object.fromEntries(
    Object.entries(groups).filter(([_, vars]) => vars.length > 0)
  );
}

/**
 * Generates a section for a specific prefix group
 * @param {string} prefix - Group prefix name
 * @param {Array} variables - Variables in this group
 * @param {Object} styles - Full style data
 * @returns {string} - Formatted section
 */
function generatePrefixSection(prefix, variables, styles) {
  const titles = {
    'brand': 'Brand Colors',
    'sidebar': 'Sidebar Colors',
    'chart': 'Chart/Data Visualization Colors',
    'semantic': 'Semantic UI Colors',
    'other': 'Other CSS Variables'
  };

  let section = `### ${titles[prefix] || prefix}\n\n`;

  variables.forEach(({ name, themes }) => {
    const cleanName = name.replace('--', '');

    // Get theme values
    const lightValue = themes.light || themes[Object.keys(themes)[0]];
    const darkValue = themes.dark;

    section += `- **${cleanName}**: \`${lightValue}\``;

    // Add normalized color if available
    const normalizedLight = normalizeColorInMarkdown(lightValue);
    if (normalizedLight) {
      section += ` (${normalizedLight})`;
    }

    section += `\n`;

    // Show dark mode variant if exists
    if (darkValue && darkValue !== lightValue) {
      section += `  - **Dark mode**: \`${darkValue}\``;
      const normalizedDark = normalizeColorInMarkdown(darkValue);
      if (normalizedDark) {
        section += ` (${normalizedDark})`;
      }
      section += `\n`;
    }
  });

  section += `\n`;
  return section;
}

/**
 * Finds colors that don't map to any CSS variable
 * @param {Object} styles - Style data
 * @returns {Array} - Unmapped colors
 */
function findUnmappedColors(styles) {
  const mappedColors = new Set();

  // Collect all colors that are mapped to CSS variables
  for (const varArray of Object.values(styles.colorMap || {})) {
    for (const varInfo of varArray) {
      // This color is mapped, so add it to the set
      const normalizedValue = normalizeColorInMarkdown(varInfo.originalValue);
      if (normalizedValue) {
        mappedColors.add(normalizedValue);
      }
    }
  }

  // Find computed colors that aren't in the mapped set
  const unmappedColors = [];
  for (const color of styles.colors || []) {
    if (!mappedColors.has(color) && !isColorMapped(color, styles.colorMap)) {
      unmappedColors.push(color);
    }
  }

  return unmappedColors.slice(0, 10); // Limit to 10
}

/**
 * Checks if a color is mapped to any CSS variable
 * @param {string} color - Color to check
 * @param {Object} colorMap - Color mapping object
 * @returns {boolean} - True if mapped
 */
function isColorMapped(color, colorMap) {
  return colorMap && colorMap[color] && colorMap[color].length > 0;
}

/**
 * Attempts to normalize a color for display in markdown
 * @param {string} color - Color value
 * @returns {string|null} - Normalized color or null
 */
function normalizeColorInMarkdown(color) {
  if (!color) return null;

  // Return as-is for common formats
  if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl') ||
      color.startsWith('oklch') || color.startsWith('lch') || color.startsWith('lab')) {
    return color;
  }

  // For var() references, just return as-is
  if (color.includes('var(')) {
    return color;
  }

  return color;
}

/**
 * Generates the typography section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateTypographySection(styles) {
  let section = '';

  // Typography section
  if (styles.fonts && styles.fonts.length > 0) {
    section += `## ğŸ“ Typography\n\n`;
    section += `### Font Families\n\n`;

    styles.fonts.forEach((font, index) => {
      section += `${index + 1}. ${font}\n`;
    });

    section += `\n`;
  }

  // Font sizes
  if (styles.fontSizes && styles.fontSizes.length > 0) {
    section += `### Font Sizes\n\n`;

    styles.fontSizes.forEach((size, index) => {
      section += `- **Size ${index + 1}**: ${size}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the spacing section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateSpacingSection(styles) {
  let section = '';

  if (styles.spacing && styles.spacing.length > 0) {
    section += `## ğŸ“ Spacing\n\n`;
    section += `### Common Spacing Values\n\n`;

    styles.spacing.forEach((space, index) => {
      section += `- **Space ${index + 1}**: ${space}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the border radius section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateBorderRadiusSection(styles) {
  let section = '';

  if (styles.borderRadius && styles.borderRadius.length > 0) {
    section += `## ğŸ”² Border Radius\n\n`;

    styles.borderRadius.forEach((radius, index) => {
      section += `- **Radius ${index + 1}**: ${radius}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the shadows section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateShadowsSection(styles) {
  let section = '';

  // Typography section
  if (styles.fonts && styles.fonts.length > 0) {
    markdown += `## ğŸ“ Typography\n\n`;
    markdown += `### Font Families\n\n`;

    styles.fonts.forEach((font, index) => {
      markdown += `${index + 1}. ${font}\n`;
    });

    markdown += `\n`;
  }

  // Font sizes
  if (styles.fontSizes && styles.fontSizes.length > 0) {
    markdown += `### Font Sizes\n\n`;

    styles.fontSizes.forEach((size, index) => {
      markdown += `- **Size ${index + 1}**: ${size}\n`;
    });

    markdown += `\n`;
  }

  // Spacing section
  if (styles.spacing && styles.spacing.length > 0) {
    markdown += `## ğŸ“ Spacing\n\n`;
    markdown += `### Common Spacing Values\n\n`;

    styles.spacing.forEach((space, index) => {
      markdown += `- **Space ${index + 1}**: ${space}\n`;
    });

    markdown += `\n`;
  }

  // Border radius section
  if (styles.borderRadius && styles.borderRadius.length > 0) {
    markdown += `## ğŸ”² Border Radius\n\n`;

    styles.borderRadius.forEach((radius, index) => {
      markdown += `- **Radius ${index + 1}**: ${radius}\n`;
    });

    markdown += `\n`;
  }

  // Shadows section
  if (styles.shadows && styles.shadows.length > 0) {
    markdown += `## ğŸŒ“ Shadows\n\n`;

    styles.shadows.forEach((shadow, index) => {
      markdown += `- **Shadow ${index + 1}**: \`${shadow}\`\n`;
    });

    markdown += `\n`;
  }

  // Footer with usage notes
  markdown += `---\n\n`;
  markdown += `## ğŸ“– Usage Notes\n\n`;
  markdown += `This design system was automatically extracted from the web page. `;
  markdown += `You may need to refine and organize these tokens based on your specific needs.\n\n`;
  markdown += `### Next Steps\n\n`;
  markdown += `1. Review and deduplicate similar values\n`;
  markdown += `2. Assign semantic names to colors and spacing values\n`;
  markdown += `3. Organize into a design token structure\n`;
  markdown += `4. Integrate into your design system or component library\n`;

  return markdown;
}

/**
 * Copies the generated Markdown to clipboard
 */
async function handleCopy() {
  try {
    await navigator.clipboard.writeText(generatedMarkdown);
    showSuccess('âœ… Copied to clipboard!');
  } catch (error) {
    console.error('Copy error:', error);
    showSuccess('âŒ Failed to copy');
  }
}

/**
 * Downloads the generated Markdown as a .md file
 */
function handleDownload() {
  try {
    // Create a Blob from the markdown content
    const blob = new Blob([generatedMarkdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);

    // Generate filename with timestamp
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `design-system-${timestamp}.md`;

    // Create a temporary download link and trigger it
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = filename;
    downloadLink.click();

    // Clean up
    URL.revokeObjectURL(url);

    showSuccess('âœ… Downloaded successfully!');
  } catch (error) {
    console.error('Download error:', error);
    showSuccess('âŒ Failed to download');
  }
}

/**
 * Shows the loading state
 */
function showLoading() {
  scanBtn.disabled = true;
  loadingState.classList.remove('hidden');
  resultsSection.classList.add('hidden');
  errorState.classList.add('hidden');
}

/**
 * Shows the results section
 */
function showResults() {
  scanBtn.disabled = false;
  loadingState.classList.add('hidden');
  resultsSection.classList.remove('hidden');
  errorState.classList.add('hidden');
}

/**
 * Shows the error state
 */
function showError() {
  scanBtn.disabled = false;
  loadingState.classList.add('hidden');
  resultsSection.classList.add('hidden');
  errorState.classList.remove('hidden');
}

/**
 * Shows a success message temporarily
 * @param {string} message - Message to display
 */
function showSuccess(message) {
  successMessage.textContent = message;
  successMessage.classList.remove('hidden');

  // Hide after 3 seconds
  setTimeout(() => {
    successMessage.classList.add('hidden');
  }, 3000);
}
