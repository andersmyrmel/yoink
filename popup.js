/**
 * Yoink Popup Script
 *
 * Handles the extension popup UI interactions:
 * - Triggers style scanning on the active tab
 * - Receives extracted styles from content script
 * - Generates enhanced Markdown design system with CSS variables
 * - Provides copy to clipboard and download functionality
 */

// DOM element references
const scanBtn = document.getElementById('scanBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const loadingState = document.getElementById('loadingState');
const resultsSection = document.getElementById('resultsSection');
const errorState = document.getElementById('errorState');
const markdownPreview = document.getElementById('markdownPreview');
const successMessage = document.getElementById('successMessage');

// Store the generated markdown globally for copy/download operations
let generatedMarkdown = '';

/**
 * Initialize popup when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', () => {
  // Attach event listeners
  scanBtn.addEventListener('click', handleScan);
  copyBtn.addEventListener('click', handleCopy);
  downloadBtn.addEventListener('click', handleDownload);
});

/**
 * Handles the scan button click
 * Sends a message to the content script to extract page styles
 */
async function handleScan() {
  try {
    // Update UI to show loading state
    showLoading();

    // Get the active tab
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

    // Send message to content script to scan the page
    chrome.tabs.sendMessage(
      tab.id,
      { action: 'scanStyles' },
      (response) => {
        if (chrome.runtime.lastError) {
          console.error('Error:', chrome.runtime.lastError);
          showError();
          return;
        }

        if (response && response.success) {
          // Process the extracted styles
          handleScanResults(response.data, tab.url);
        } else {
          showError();
        }
      }
    );
  } catch (error) {
    console.error('Scan error:', error);
    showError();
  }
}

/**
 * Processes scan results and generates Markdown
 * @param {Object} styleData - Extracted style data from content script
 * @param {string} url - The URL of the scanned page
 */
function handleScanResults(styleData, url) {
  // Generate Markdown design system
  generatedMarkdown = generateMarkdown(styleData, url);

  // Update preview
  markdownPreview.textContent = generatedMarkdown;

  // Show results section
  showResults();
}

/**
 * Generates a Markdown design system from extracted styles
 * @param {Object} styles - Style data object
 * @param {string} url - Source URL
 * @returns {string} - Formatted Markdown document
 */
function generateMarkdown(styles, url) {
  const timestamp = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  let markdown = `# Design System\n\n`;
  markdown += `**Source:** ${url}\n`;
  markdown += `**Extracted:** ${timestamp}\n`;
  markdown += `**Generated by:** Yoink Extension\n\n`;
  markdown += `---\n\n`;

  // Generate enhanced color section with CSS variables
  markdown += generateColorSection(styles);

  // Generate radius section if we have CSS variables for it
  const groupedVars = groupCSSVariablesByPrefix(styles.cssVariables);
  if (groupedVars.radius && groupedVars.radius.length > 0) {
    markdown += generatePrefixSection('radius', groupedVars.radius, styles);
  } else {
    // Fallback to computed border radius if no CSS variables
    markdown += generateBorderRadiusSection(styles);
  }

  // Keep existing sections for other design tokens
  markdown += generateTypographySection(styles);
  markdown += generateSpacingSection(styles);
  markdown += generateShadowsSection(styles);

  // Footer with usage notes
  markdown += `---\n\n`;
  markdown += `## ðŸ“– Usage Notes\n\n`;
  markdown += `This design system was automatically extracted from the web page. `;
  markdown += `CSS custom properties (variables) have been extracted and mapped to their computed values.\n\n`;
  markdown += `### Next Steps\n\n`;
  markdown += `1. Use the CSS variable names (e.g., \`var(--medical-primary)\`) in your code\n`;
  markdown += `2. Review and consolidate duplicate semantic names\n`;
  markdown += `3. Verify theme variants work correctly in light/dark modes\n`;
  markdown += `4. Integrate into your design system or component library\n`;

  return markdown;
}

/**
 * Generates the enhanced color section with semantic CSS variables
 * @param {Object} styles - Style data object
 * @returns {string} - Formatted color section
 */
function generateColorSection(styles) {
  let section = `## ðŸŽ¨ Colors\n\n`;

  // Group CSS variables by prefix
  const groupedVars = groupCSSVariablesByPrefix(styles.cssVariables);

  // Define the order we want to display groups
  const displayOrder = ['brand', 'sidebar', 'chart', 'semantic', 'other'];

  // Generate sections for priority groups
  for (const prefix of displayOrder) {
    if (groupedVars[prefix] && groupedVars[prefix].length > 0) {
      section += generatePrefixSection(prefix, groupedVars[prefix], styles);
    }
  }

  // Show computed colors without CSS variables
  const computedColors = findUnmappedColors(styles);
  if (computedColors.length > 0) {
    section += `### ðŸŽ¯ Computed Values (hardcoded, not using CSS variables)\n\n`;
    section += `_These colors are hardcoded in the HTML/CSS. Consider refactoring to use CSS variables._\n\n`;
    computedColors.forEach((color) => {
      const usage = styles.colorUsage?.[color] || 0;
      section += `- \`${color}\``;
      if (usage > 0) {
        section += ` - Used in ${usage} element${usage !== 1 ? 's' : ''}`;
      }
      section += `\n`;
    });
    section += `\n`;
  }

  // Add Tailwind section as collapsible (if present)
  if (groupedVars.tailwind && groupedVars.tailwind.length > 0) {
    section += `<details>\n`;
    section += `<summary>ðŸ“¦ Tailwind Default Palette (${groupedVars.tailwind.length} colors - click to expand)</summary>\n\n`;
    section += `_These are Tailwind's default color utilities. They may not be part of your custom design system._\n\n`;

    groupedVars.tailwind.slice(0, 20).forEach(({ name, themes }) => {
      const cleanName = name.replace('--', '');
      const value = themes.light || themes[Object.keys(themes)[0]];
      section += `- **${cleanName}**: \`${value}\`\n`;
    });

    if (groupedVars.tailwind.length > 20) {
      section += `\n_... and ${groupedVars.tailwind.length - 20} more_\n`;
    }

    section += `\n</details>\n\n`;
  }

  return section;
}

/**
 * Groups CSS variables by their prefix (e.g., medical-, sidebar-, etc.)
 * @param {Object} cssVars - CSS variables object
 * @returns {Object} - Grouped variables
 */
function groupCSSVariablesByPrefix(cssVars) {
  const groups = {
    'brand': [],       // medical-, brand-, company- prefixes
    'sidebar': [],     // sidebar- prefix
    'chart': [],       // chart-, graph-, data- prefixes
    'semantic': [],    // background, foreground, primary, secondary, accent, etc.
    'radius': [],      // border radius variables
    'tailwind': [],    // Tailwind default palette (color-*)
    'other': []        // everything else
  };

  for (const [varName, themes] of Object.entries(cssVars || {})) {
    const cleanName = varName.replace('--', '');
    const lower = cleanName.toLowerCase();

    // Check if this is a Tailwind default color (--color-* or --tw-*)
    if (lower.startsWith('color-') || lower.startsWith('tw-')) {
      groups.tailwind.push({ name: varName, themes });
      continue; // Don't categorize further
    }

    // Check if this is a radius variable
    if (lower.includes('radius')) {
      groups.radius.push({ name: varName, themes });
      continue;
    }

    // Categorize ALL variables by prefix (not just colors)
    // This ensures we don't lose any CSS variables
    if (lower.startsWith('medical-') || lower.startsWith('brand-') || lower.startsWith('company-')) {
      groups.brand.push({ name: varName, themes });
    } else if (lower.startsWith('sidebar-')) {
      groups.sidebar.push({ name: varName, themes });
    } else if (lower.startsWith('chart-') || lower.startsWith('graph-') || lower.startsWith('data-')) {
      groups.chart.push({ name: varName, themes });
    } else if (['background', 'foreground', 'primary', 'secondary', 'accent', 'muted', 'border', 'input', 'ring', 'destructive', 'card', 'popover'].some(s => lower.includes(s))) {
      groups.semantic.push({ name: varName, themes });
    } else {
      // Everything else goes to 'other' (but we still show it!)
      groups.other.push({ name: varName, themes });
    }
  }

  // Remove empty groups
  return Object.fromEntries(
    Object.entries(groups).filter(([_, vars]) => vars.length > 0)
  );
}

/**
 * Checks if a value looks like a color
 * @param {string} value - Value to check
 * @returns {boolean} - True if it looks like a color
 */
function looksLikeColor(value) {
  if (!value) return false;
  const lower = value.toLowerCase().trim();
  return (
    lower.startsWith('#') ||
    lower.startsWith('rgb') ||
    lower.startsWith('hsl') ||
    lower.startsWith('oklch') ||
    lower.startsWith('lch') ||
    lower.startsWith('lab') ||
    lower === 'transparent' ||
    lower === 'currentcolor'
  );
}

/**
 * Generates a section for a specific prefix group
 * @param {string} prefix - Group prefix name
 * @param {Array} variables - Variables in this group
 * @param {Object} styles - Full style data
 * @returns {string} - Formatted section
 */
function generatePrefixSection(prefix, variables, styles) {
  const titles = {
    'brand': 'ðŸ¥ Brand Colors',
    'sidebar': 'ðŸ“Š Sidebar Colors',
    'chart': 'ðŸ“ˆ Chart Colors',
    'semantic': 'ðŸŽ¨ Semantic UI Colors',
    'radius': 'ðŸ”² Border Radius',
    'other': 'Other CSS Variables'
  };

  const emojis = {
    'brand': '(brand-*, medical-*, company-*)',
    'sidebar': '(sidebar-*)',
    'chart': '(chart-*, graph-*, data-*)',
    'semantic': '(background, foreground, primary, etc.)',
    'radius': '(radius, rounded, etc.)'
  };

  let section = `### ${titles[prefix] || prefix}`;
  if (emojis[prefix]) {
    section += ` ${emojis[prefix]}`;
  }
  section += `\n\n`;

  variables.forEach(({ name, themes }) => {
    const cleanName = name.replace('--', '');

    // Get theme values
    const lightValue = themes.light || themes[Object.keys(themes)[0]];
    const darkValue = themes.dark;

    // Check if we have both light and dark modes
    const hasBothModes = darkValue && darkValue !== lightValue;

    // Check if this variable is actually used (has a color in colorUsage)
    const normalizedLight = normalizeToRGB(lightValue);
    const usage = styles.colorUsage?.[normalizedLight] || styles.colorUsage?.[lightValue] || 0;

    if (hasBothModes) {
      // Show both modes inline
      section += `- **${cleanName}**:\n`;
      section += `  - Light: \`${lightValue}\``;

      // Add normalized RGB for light mode
      if (normalizedLight && normalizedLight !== lightValue) {
        section += ` â†’ ${normalizedLight}`;
      }

      // Add usage count if available
      if (usage > 0) {
        section += `\n    _Used in ${usage} element${usage !== 1 ? 's' : ''}_`;
      }
      section += `\n`;

      section += `  - Dark: \`${darkValue}\``;

      // Add normalized RGB for dark mode
      const normalizedDark = normalizeToRGB(darkValue);
      if (normalizedDark && normalizedDark !== darkValue) {
        section += ` â†’ ${normalizedDark}`;
      }
      section += `\n`;
    } else {
      // Single value (no dark mode or same value)
      section += `- **${cleanName}**: \`${lightValue}\``;

      // Add normalized RGB
      if (normalizedLight && normalizedLight !== lightValue) {
        section += ` â†’ ${normalizedLight}`;
      }

      // Add usage count if available
      if (usage > 0) {
        section += `\n  _Used in ${usage} element${usage !== 1 ? 's' : ''}_`;
      }
      section += `\n`;
    }
  });

  section += `\n`;
  return section;
}

/**
 * Normalizes a color to RGB format for display
 * @param {string} color - Color value
 * @returns {string|null} - RGB representation or null
 */
function normalizeToRGB(color) {
  if (!color || !looksLikeColor(color)) return null;

  // Already in a standard format
  if (color.startsWith('rgb(') || color.startsWith('rgba(')) {
    return color;
  }

  // For oklch/lch/lab, show as-is (browsers handle differently)
  if (color.startsWith('oklch(') || color.startsWith('lch(') || color.startsWith('lab(')) {
    return null; // Keep original format
  }

  // Try to convert hex to rgb
  if (color.startsWith('#')) {
    const hex = color.replace('#', '');
    if (hex.length === 3) {
      const r = parseInt(hex[0] + hex[0], 16);
      const g = parseInt(hex[1] + hex[1], 16);
      const b = parseInt(hex[2] + hex[2], 16);
      return `rgb(${r}, ${g}, ${b})`;
    } else if (hex.length === 6) {
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      return `rgb(${r}, ${g}, ${b})`;
    }
  }

  return null;
}

/**
 * Finds colors that don't map to any CSS variable
 * @param {Object} styles - Style data
 * @returns {Array} - Unmapped colors
 */
function findUnmappedColors(styles) {
  const mappedColors = new Set();

  // Collect all normalized values from CSS variables
  for (const themes of Object.values(styles.cssVariables || {})) {
    for (const value of Object.values(themes)) {
      if (looksLikeColor(value)) {
        const normalized = normalizeColorInMarkdown(value);
        if (normalized) {
          mappedColors.add(normalized);
        }
      }
    }
  }

  // Also check the colorMap
  for (const color of Object.keys(styles.colorMap || {})) {
    mappedColors.add(color);
  }

  // Find computed colors that aren't in the mapped set
  const unmappedColors = [];
  for (const color of styles.colors || []) {
    if (!mappedColors.has(color)) {
      unmappedColors.push(color);
    }
  }

  return unmappedColors.slice(0, 10); // Limit to 10
}

/**
 * Attempts to normalize a color for display in markdown
 * @param {string} color - Color value
 * @returns {string|null} - Normalized color or null
 */
function normalizeColorInMarkdown(color) {
  if (!color) return null;

  // Return as-is for common formats
  if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl') ||
      color.startsWith('oklch') || color.startsWith('lch') || color.startsWith('lab')) {
    return color;
  }

  // For var() references, just return as-is
  if (color.includes('var(')) {
    return color;
  }

  return color;
}

/**
 * Generates the typography section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateTypographySection(styles) {
  let section = '';

  // Typography section
  if (styles.fonts && styles.fonts.length > 0) {
    section += `## ðŸ“ Typography\n\n`;
    section += `### Font Families\n\n`;

    styles.fonts.forEach((font, index) => {
      section += `${index + 1}. ${font}\n`;
    });

    section += `\n`;
  }

  // Font sizes
  if (styles.fontSizes && styles.fontSizes.length > 0) {
    section += `### Font Sizes\n\n`;

    styles.fontSizes.forEach((size, index) => {
      section += `- **Size ${index + 1}**: ${size}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the spacing section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateSpacingSection(styles) {
  let section = '';

  if (styles.spacing && styles.spacing.length > 0) {
    section += `## ðŸ“ Spacing\n\n`;
    section += `### Common Spacing Values\n\n`;

    styles.spacing.forEach((space, index) => {
      section += `- **Space ${index + 1}**: ${space}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the border radius section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateBorderRadiusSection(styles) {
  let section = '';

  if (styles.borderRadius && styles.borderRadius.length > 0) {
    section += `## ðŸ”² Border Radius\n\n`;

    styles.borderRadius.forEach((radius, index) => {
      section += `- **Radius ${index + 1}**: ${radius}\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Generates the shadows section
 * @param {Object} styles - Style data
 * @returns {string} - Formatted section
 */
function generateShadowsSection(styles) {
  let section = '';

  if (styles.shadows && styles.shadows.length > 0) {
    section += `## ðŸŒ“ Shadows\n\n`;

    styles.shadows.forEach((shadow, index) => {
      section += `- **Shadow ${index + 1}**: \`${shadow}\`\n`;
    });

    section += `\n`;
  }

  return section;
}

/**
 * Copies the generated Markdown to clipboard
 */
async function handleCopy() {
  try {
    await navigator.clipboard.writeText(generatedMarkdown);
    showSuccess('âœ… Copied to clipboard!');
  } catch (error) {
    console.error('Copy error:', error);
    showSuccess('âŒ Failed to copy');
  }
}

/**
 * Downloads the generated Markdown as a .md file
 */
function handleDownload() {
  try {
    // Create a Blob from the markdown content
    const blob = new Blob([generatedMarkdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);

    // Generate filename with timestamp
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `design-system-${timestamp}.md`;

    // Create a temporary download link and trigger it
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = filename;
    downloadLink.click();

    // Clean up
    URL.revokeObjectURL(url);

    showSuccess('âœ… Downloaded successfully!');
  } catch (error) {
    console.error('Download error:', error);
    showSuccess('âŒ Failed to download');
  }
}

/**
 * Shows the loading state
 */
function showLoading() {
  scanBtn.disabled = true;
  loadingState.classList.remove('hidden');
  resultsSection.classList.add('hidden');
  errorState.classList.add('hidden');
}

/**
 * Shows the results section
 */
function showResults() {
  scanBtn.disabled = false;
  loadingState.classList.add('hidden');
  resultsSection.classList.remove('hidden');
  errorState.classList.add('hidden');
}

/**
 * Shows the error state
 */
function showError() {
  scanBtn.disabled = false;
  loadingState.classList.add('hidden');
  resultsSection.classList.add('hidden');
  errorState.classList.remove('hidden');
}

/**
 * Shows a success message temporarily
 * @param {string} message - Message to display
 */
function showSuccess(message) {
  successMessage.textContent = message;
  successMessage.classList.remove('hidden');

  // Hide after 3 seconds
  setTimeout(() => {
    successMessage.classList.add('hidden');
  }, 3000);
}
